module mat_kelvin_voigt

  use prop_mat

  implicit none
  private

 !-- kelvin-voigt
  type matwrk_kv_type
    private
    double precision, pointer :: eta(:,:) => null()
  end type matwrk_kv_type
  
  integer, save :: isKelvinVoigt = 0
  logical, save :: NormalizeByDT=.true.

  ! for memory report
  integer, save :: MAT_KV_mempro = 0
  integer, save :: MAT_KV_memwrk = 0

  public :: matwrk_kv_type &
          , MAT_isKelvinVoigt, MAT_KV_read, MAT_KV_init_elem_prop &
          , MAT_KV_init_elem_work, MAT_KV_add_etav &
          , MAT_KV_mempro, MAT_KV_memwrk

contains

!=======================================================================
  logical function MAT_isKelvinVoigt(m)

  type(matpro_elem_type), intent(in) :: m

  MAT_isKelvinVoigt = MAT_isKind(m,isKelvinVoigt)

  end function MAT_isKelvinVoigt

!=======================================================================
! BEGIN INPUT BLOCK
!
! NAME   : MAT_KV
! GROUP  : MATERIALS
! PURPOSE: Sets material properties for a Kelvin-Voigt viscous material.
!          Adds a damping term C*v = K*eta*v, where eta is a viscous time.
!          This produces attenuation with frequency-dependent quality factor
!            Q(f) = 1/(eta*2*pi*f)
!          Its main usage is for artificial damping of high-frequency 
!          numerical artifacts generated by dynamic faults, which requires a
!          thin layer of Kelvin-Voigt elements surrounding the fault
!          with eta/dt = 0.1 to 0.3 and a layer thickness of 1 to 2 elements
!          on each side of the fault.
! SYNTAX : &MAT_KV eta, ETAxDT /
!          &MAT_KV etaH, ETAxDT / followed by a DIST_XXX input block
!
! ARG: eta      [dble][0d0] Viscosity coefficient
! ARG: ETAxDT   [log][T] If eta is given in units of dt (timestep)
!
! NOTE   : Kelvin-Voigt viscosity modifies the stability of time integration.
!          The timestep (or the Courant number) must be set to a value
!          smaller than usual. The critical timestep for a Kelvin-Voigt material 
!          integrated with the leapfrog time scheme is
!            dtc_kv = eta*( sqrt(1+dtc^2/eta^2)-1 )
!          where dtc is the critical timestep for a purely elastic medium (eta=0).
!          In terms of the normalized viscosity (if ETAxDT=T):
!            dtc_kv = dtc / sqrt( 1+ 2*eta)
!
! END INPUT BLOCK

 
  subroutine MAT_KV_read(input,iin)

  use echo, only : echo_input, iout
  use stdio, only : IO_abort

  type (matpro_input_type), intent(inout) :: input
  integer, intent(in) :: iin

  double precision :: eta
  character(20) :: etaH
  logical :: ETAxDT

  NAMELIST / MAT_KV / eta, etaH, ETAxDT

  eta = 0d0
  etaH = ' '
  ETAxDT = .true.

  read(iin, MAT_KV, END=100)

  call MAT_setKind(input,isKelvinVoigt)

  call MAT_setProp(input,'eta',eta,etaH,iin,etaH)
  NormalizeByDT = ETAxDT

  if (echo_input) write(iout,200) etaH,ETAxDT

  return
  
  100 call IO_abort('MAT_KV_read: MAT_KV input block not found')

  200   format(5x, &
    'Viscosity coefficient . . . . .(eta/etaH) = ',a,/5x, &
    'Normalized by dt. . . . . . . . .(ETAxDT) = ',L1)

  end subroutine MAT_KV_read

!=======================================================================
  subroutine MAT_KV_init_elem_prop(elem,ecoord)

  type(matpro_elem_type), intent(inout) :: elem
  double precision, intent(in) :: ecoord(:,:,:)

  call MAT_setProp(elem,'eta',ecoord,MAT_KV_mempro)

  end subroutine MAT_KV_init_elem_prop

!=======================================================================
  subroutine MAT_KV_init_elem_work(matwrk,matpro,ngll,dt)

  type(matwrk_kv_type), intent(inout) :: matwrk
  type(matpro_elem_type), intent(in) :: matpro
  double precision, intent(in) :: dt
  integer, intent(in) :: ngll

  if (.not. MAT_isKelvinVoigt(matpro)) return
  allocate( matwrk%eta(ngll,ngll) )
  call MAT_getProp(matwrk%eta, matpro,'eta')
  if (NormalizeByDT) matwrk%eta = dt * matwrk%eta

  MAT_KV_memwrk = MAT_KV_memwrk &
                + size( transfer(matwrk, (/ 0d0 /) )) &
                + size(matwrk%eta)

  end subroutine MAT_KV_init_elem_work

!=======================================================================

  subroutine MAT_KV_add_etav(d,v,m,ngll,ndof)

  integer, intent(in) :: ngll,ndof
  double precision, intent(inout) :: d(ngll,ngll,ndof)
  double precision, intent(in) :: v(ngll,ngll,ndof)
  type(matwrk_kv_type), intent(in) :: m

  integer :: i

  do i=1,ndof
    d(:,:,i) = d(:,:,i) + m%eta * v(:,:,i)
  enddo

  end subroutine MAT_KV_add_etav

end module mat_kelvin_voigt
